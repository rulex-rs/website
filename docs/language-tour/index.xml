<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Language Tour on</title><link>https://pomsky-lang.org/docs/language-tour/</link><description>Recent content in Language Tour on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Tue, 17 May 2022 13:55:00 +0000</lastBuildDate><atom:link href="https://pomsky-lang.org/docs/language-tour/index.xml" rel="self" type="application/rss+xml"/><item><title>Basics</title><link>https://pomsky-lang.org/docs/language-tour/basics/</link><pubDate>Tue, 17 May 2022 13:55:00 +0000</pubDate><guid>https://pomsky-lang.org/docs/language-tour/basics/</guid><description>First, let&amp;rsquo;s get familiar with the basic building blocks of the language.
pomsky expressions describe the syntactical structure of a text. There are several kinds of expressions, which will be explained now.
In pomsky, whitespace is insignificant, except between quotes. This means that we can add spaces and line breaks to make the code look clearer. We can also add comments to explain what the expressions are doing. They start with a # and span until the end of the line:</description></item><item><title>Groups</title><link>https://pomsky-lang.org/docs/language-tour/groups/</link><pubDate>Tue, 17 May 2022 13:55:00 +0000</pubDate><guid>https://pomsky-lang.org/docs/language-tour/groups/</guid><description>Multiple expressions can be grouped together by wrapping them in () . This is useful when we have multiple alternatives that all start or end with the same thing:
'tang' ('ible' | 'ent' | 'o') This matches the words tangible, tangent and tango.
Capturing groups #Groups can also be used to capture their content, for example to replace it with something else. In a regex, every group is a capturing group by default.</description></item><item><title>Repetitions</title><link>https://pomsky-lang.org/docs/language-tour/repetitions/</link><pubDate>Tue, 17 May 2022 13:55:00 +0000</pubDate><guid>https://pomsky-lang.org/docs/language-tour/repetitions/</guid><description>When we want to match an expression multiple times, it would be cumbersome to repeat our expression. Instead, we can specify how often the expression should occur:
('r' | 'w' | 'x' | '-'){9} This matches an r, w, x or - character 9 times. For example, it would match the string rwxr-xr--, or xxrr-xr-w.
What if we want to match strings of different lengths? Repetitions are quite flexible, so we can specify a lower and upper bound for the number of repetitions:</description></item><item><title>Character Classes</title><link>https://pomsky-lang.org/docs/language-tour/character-classes/</link><pubDate>Tue, 17 May 2022 13:55:00 +0000</pubDate><guid>https://pomsky-lang.org/docs/language-tour/character-classes/</guid><description>What if we want to match an arbitrary word? Enumerating every single word is obviously not feasible, so what to do instead? We can simply enumerate the characters and repeat them:
('a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z')+ But this very verbose and still only matches lowercase letters.</description></item><item><title>Shorthands</title><link>https://pomsky-lang.org/docs/language-tour/shorthands/</link><pubDate>Tue, 17 May 2022 13:55:00 +0000</pubDate><guid>https://pomsky-lang.org/docs/language-tour/shorthands/</guid><description>There are a few shorthand character classes: word, digit, space, horiz_space and vert_space. They can be abbreviated with their first letter: w, d, s, h and v. Like Unicode properties, they must appear in square brackets.
word matches a word character, i.e. a letter, digit or underscore. It&amp;rsquo;s equivalent to [Alphabetic Mark Decimal_Number Connector_Punctuation Join_Control] . digit matches a digit. It&amp;rsquo;s equivalent to Decimal_Number. space matches whitespace. It&amp;rsquo;s equivalent to White_Space.</description></item><item><title>Boundaries</title><link>https://pomsky-lang.org/docs/language-tour/boundaries/</link><pubDate>Tue, 17 May 2022 13:55:00 +0000</pubDate><guid>https://pomsky-lang.org/docs/language-tour/boundaries/</guid><description>Boundaries match a position in a string without consuming any code points. There are 4 boundaries:
% matches a word boundary. It matches successfully if it is preceded, but not succeeded by a word character, or vice versa. For example, Codepoint % Codepoint matches A; and ;A, but not AA or ;;.
!% matches a position that is not a word boundary. For example, Codepoint !% Codepoint matches aa and ::, but not a: or :a.</description></item><item><title>Lookaround</title><link>https://pomsky-lang.org/docs/language-tour/lookaround/</link><pubDate>Tue, 17 May 2022 13:55:00 +0000</pubDate><guid>https://pomsky-lang.org/docs/language-tour/lookaround/</guid><description>Lookarounds provide the ability to see if the characters before or after the current position match a certain expression. There are four variants:
, a positive lookahead. For example, ( [w]) matches if the position is followed by a word character. That character isn&amp;rsquo;t included in the match.
, a positive lookbehind. For example, (matches if the position is directly after a word character.</description></item><item><title>Ranges</title><link>https://pomsky-lang.org/docs/language-tour/ranges/</link><pubDate>Tue, 17 May 2022 13:55:00 +0000</pubDate><guid>https://pomsky-lang.org/docs/language-tour/ranges/</guid><description>Writing a regex matching a number in a certain range can be quite difficult. For example, the following regex matches a number between 0 and 255:
(?:2(?:5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]) This has many downsides:
It&amp;rsquo;s not readable It&amp;rsquo;s difficult to come up with It&amp;rsquo;s easy to make a mistake somewhere It&amp;rsquo;s inefficient; a typical regex engine needs to backtrack in several places pomsky solves these problems with its range syntax:</description></item><item><title>References</title><link>https://pomsky-lang.org/docs/language-tour/references/</link><pubDate>Tue, 17 May 2022 13:55:00 +0000</pubDate><guid>https://pomsky-lang.org/docs/language-tour/references/</guid><description>Sometimes it&amp;rsquo;s useful to match the same text as we matched before. For example, to match strings in single or double quotes, we can write
:(['&amp;quot;' &amp;quot;'&amp;quot;]) !['&amp;quot;' &amp;quot;'&amp;quot;]* ::1 This consists of three parts: First, there&amp;rsquo;s a capturing group matching a quote. We then match an arbitrary number of characters that aren&amp;rsquo;t quotes. Finally, there&amp;rsquo;s a ::1 reference. This matches the same text as was captured in capturing group number 1.</description></item><item><title>Variables</title><link>https://pomsky-lang.org/docs/language-tour/variables/</link><pubDate>Tue, 17 May 2022 13:55:00 +0000</pubDate><guid>https://pomsky-lang.org/docs/language-tour/variables/</guid><description>Variables are a powerful feature that is exclusive to pomsky; because no regex engine offers this functionality, variables in pomsky are &amp;ldquo;inlined&amp;rdquo;, i.e. substituted with their value recursively.
This means that variables don&amp;rsquo;t allow recursion, because otherwise the generated regular expression would have infinite size. But even without recursion, variables are a powerful and useful tool to create more complex expressions.
Variables are declared with the let keyword:
let x = 'hello' | 'world'; The above will emit nothing, because the variable is declared, but not used.</description></item></channel></rss>